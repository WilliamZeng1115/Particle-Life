<!DOCTYPE html>
<html>
<head>
<title>Particle Life</title>
</style>
</head>

<body>
<canvas class='myCanvas' onclick="updateMouse(event)">
</canvas>

<style>
  body {
    margin: 0;
    overflow: hidden;
  }
</style>

<script>
var canvas = document.querySelector('.myCanvas');
var ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

var particleCoefficents = []
for(var i = 0; i < 6; i++){
  particleCoefficents.push(Math.random()*3.5-1.5)
}

var radius = 4;
var friction = 0.999
var collisionElasticity = 0.995
var particles = [];
class particle {

  constructor(type, x, y) {
    var canvas = document.querySelector('.myCanvas');
    this.ctx = canvas.getContext('2d');
    this.type = type;
    this.x = x;
    this.y = y;

    switch(type){
      case 0:
        this.color = 'rgb(159, 26, 189)'
        break;
      case 1:
        this.color = 'rgb(78, 189, 26)'
        break;
      case 2:
        this.color = 'rgb(17, 242, 250)'
        break;
      case 3:
        this.color = 'rgb(250, 17, 64)'
        break;
      case 4:
        this.color = 'rgb(250, 188, 17)'
        break;
      default:
        this.color = 'rgb(255, 255, 255)'
        break;
      }

    this.ctx.fillStyle = this.color;

    this.velocityx = (Math.random() - 0.5);
    this.velocityy = (Math.random() - 0.5);
  }

  renderImage() {
    this.ctx.beginPath();
    this.ctx.arc(this.x, this.y, radius, 0, 2 * Math.PI);
    this.ctx.fillStyle = this.color;
    this.ctx.fill();
  }

  wallCheck(){
    if(this.x < radius || this.x > (window.innerWidth - radius)){
      this.velocityx *= -1;
    }

    if(this.y < radius || this.y > (window.innerHeight - radius)){
      this.velocityy *= -1;
    }
  }

  move() {
    this.wallCheck();
    this.renderImage();

    this.x += this.velocityx;
    this.y += this.velocityy;
    this.velocityx *= friction;
    this.velocityy *= friction;
  }
}

function updateMouse(event) {
  var particleBase = new particle(Math.floor(Math.random()*6), event.clientX,  event.clientY);
  particles.push(particleBase);
  particleBase.renderImage();
}

function collisionCheck(part1, part2){
  if(distance(part1, part2) < radius*2){
    var tempx = part1.velocityx*collisionElasticity;
    var tempy = part1.velocityy*collisionElasticity;
    part1.velocityx = part2.velocityx*collisionElasticity;
    part1.velocityy = part2.velocityy*collisionElasticity;
    part2.velocityx = tempx;
    part2.velocityy = tempy;
  }
}

function distance(part1, part2){
  return Math.sqrt((part1.x - part2.x)**2 + (part1.y - part2.y)**2);
}

function force(forced, forcing){
  var distance = distance(forced, forcing)/radius;

  if(distance < 4){
    var force = ((distance - 4)**2)/3;
  } else if(distance > 6 && distance < 8){
    var force = 1.5*distance-9;
  } else if(distance > 8 && distance < 10){
    var force = -1.5*distance+15;
  } else {
    var force = 0;
  }

  force *= particleCoefficents[forced.type] * particleCoefficents[forcing.type]

  forced.velocityx += force*((forced.x - forcing.x)/distance)
  forced.velocityy += force*((forced.y - forcing.y)/distance)
}

function loop(){
  const context = canvas.getContext('2d');
  context.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'rgb(0, 0, 0)';
  ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

  for(var i = 0; i < particles.length; i++){
    for(var j = i + 1; j < particles.length; j++){
      collisionCheck(particles[i], particles[j]);
    }
  }

  for(var i = 0; i < particles.length; i++){
    for(var j = 0; j < particles.length; j++){
      if(i != j){
        force(particles[i], particles[j]);
      }
    }
  }

  particles.forEach(function(element) {
    element.move();
  });

  requestAnimationFrame(loop);
}

loop();

</script>
</body>
</html>
