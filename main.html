<!DOCTYPE html>
<html>
<head>
<title>Particles</title>
</style>
</head>

<body>
<canvas class='myCanvas' onclick='updateMouse(event)'>
</canvas>

<style>
  body {
    margin: 0;
    overflow:
    hidden;
  }
</style>

<script>
var canvas = document.querySelector('.myCanvas');
var ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

var forceMultiplyer = 0.1;
var radius = 4;
var friction = 0.98;
var particles = [];
var particleCoefficents = [[],[],[],[],[],[]];
for(var i = 0; i < 6; i++){
  for(var j = 0; j < 6; j++){
    particleCoefficents[i][j]= Math.random()*4-2;
  }
}

class particle {

  constructor(type, x, y) {
    var canvas = document.querySelector('.myCanvas');
    this.ctx = canvas.getContext('2d');
    this.type = type;
    this.x = x;
    this.y = y;

    switch(type){
      case 0:
        this.color = 'rgb(159, 26, 189)'
        break;
      case 1:
        this.color = 'rgb(78, 189, 26)'
        break;
      case 2:
        this.color = 'rgb(17, 242, 250)'
        break;
      case 3:
        this.color = 'rgb(250, 17, 64)'
        break;
      case 4:
        this.color = 'rgb(250, 188, 17)'
        break;
      default:
        this.color = 'rgb(255, 255, 255)'
        break;
      }

    this.ctx.fillStyle = this.color;

    this.velocityx = 0;
    this.velocityy = 0;
  }

  renderImage() {
    this.ctx.beginPath();
    this.ctx.arc(this.x, this.y, radius, 0, 2 * Math.PI);
    this.ctx.fillStyle = this.color;
    this.ctx.fill();
  }

  wallCheck(){
    if(this.x < radius || this.x > (window.innerWidth - radius)){
      this.velocityx *= -1;
    }

    if(this.y < radius || this.y > (window.innerHeight - radius)){
      this.velocityy *= -1;
    }
  }

  move() {
    this.x += this.velocityx;
    this.y += this.velocityy;

    this.velocityx *= friction;
    this.velocityy *= friction;
  }
}

function collisionChecker(part1, part2){
  if(Math.sqrt((part1.x - part2.x)**2 + (part1.y - part2.y)**2) < radius*2){
    part1.velocityx = part2.velocityx = (part1.velocityx + part2.velocityx)/2;
    part1.velocityy = part2.velocityy = (part1.velocityy + part2.velocityy)/2;
  }
}

function updateMouse(event) {
  var particleBase = new particle(Math.floor(Math.random()*6), event.clientX,  event.clientY);
  particles.push(particleBase);
  particleBase.renderImage();
}

function force(forced, forcing){
  var distance = Math.sqrt((forced.x - forcing.x)**2 + (forced.y - forcing.y)**2);
  var force = 0

  if(distance < 2*radius){
    force = ((distance - 2*radius)**2)/(radius) * -1 * forceMultiplyer;
  }

  if(distance > radius*2 && distance < radius*5){
    force = 0.5*(distance-2*radius);
    force *= particleCoefficents[forced.type][forcing.type] * forceMultiplyer;
  } else if(distance > radius*5 && distance < radius*8){
    force = -0.5*(distance-8*radius);
    force *= particleCoefficents[forced.type][forcing.type] * forceMultiplyer;
  }

  forced.velocityx += force*((forced.x - forcing.x)/distance);
  forced.velocityy += force*((forced.y - forcing.y)/distance);
}

function loop(){
  const context = canvas.getContext('2d');
  context.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'rgb(0, 0, 0)';
  ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

  for(var i = 0; i < particles.length; i++){
    for(var j = 0; j < particles.length; j++){
      if(i != j){
        force(particles[i], particles[j]);
      }
    }

    for(var i = 0; i < particles.length; i++){
      for(var j = i + 1; j < particles.length; j++){
        collisionChecker(particles[i], particles[j]);
      }
    }
  }

  particles.forEach(function(element) {
    element.move();
    element.renderImage();
    element.wallCheck();
  });

  requestAnimationFrame(loop);
}

loop();

</script>
</body>
</html>
